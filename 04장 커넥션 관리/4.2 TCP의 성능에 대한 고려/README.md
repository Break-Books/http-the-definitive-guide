# 4.2 TCP 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에, HTTP 트랜잭션의 성능은 TCP 성능에 영향을 받는다.

## 4.2.1 HTTP 트랜잭션 지연

### 트랜잭션을 지연시키는 원인
- 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야 한다. 만약 URI에 기술되어 있는 호스트에 방문한 적이 없으면, DNS 이름 분석 인프라를 사용하여 URI에 있는 호스트 명을 IP 주소로 변환하는데 수십 초의 시간이 걸릴 것이다. (현재는 인프라의 발전으로 밀리초 단위로 DNS 이름 분석이 끝난다.)
- 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다.
- 커넥션이 맺어지면 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송, 웹 서버는 도착하는 대로 TCP 커넥션에서 요청 메시지를 읽고 처리한다.
- 웹 서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.

<br>

## 4.2.2 성능 관련 중요 요소
- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

<br>

## 4.2.3 TCP 커넥션 핸드셰이크 지연
새로운 커넥션을 위해 연속으로 IP 패킷을 교환한다. : `3-way handshake`

### 3-way handshake 과정
1. 클라이언트는 TCP 패킷 `SYN` 을 서버에게 보낸다. 이 과정을 커넥션 생성 요청이라고 한다.
2. 커넥션 요청이 받아들여지면 서버는 `SYN과 ACK` 플래그를 포함한 TCP 패킷을 돌려보낸다.
3. 클라이언트는 최종적으로, 서로 간에 통신이 잘 이루어지고 있음을 서버에게 알리기 위해, 한 번 더 신호를 보낸다.


**이러한 과정으로 인해 크기가 작은 HTTP 트랜잭션은 handshake 로 인한 오버헤드가 부담이 될 수 있다.**

<br>

## 4.2.4 확인응답 지연
각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다. 
각 세그먼트 수신자는, 세그먼트를 받으면 확인응답 패킷을 반환한다. 만일 반환이 없다면 패킷이 파기되었거나 오류가 있다고 판단해 재전송한다.

이 때 확인응답은 크기가 작기 때문에 같은 방향으로 보내야 할 데이터 패킷에, 확인 응답을 편승(piggyback)시킨다.

하지만 막상 편승을 하려고 하더라도 같은 방향으로 보내는 패킷이 많지는 않을 것이기 때문에, 이 지연으로 인해 속도가 느려질 수 있다. 따라서 지연 관련 기능을 수정하거나 비활성화할 수 있다.

<br>

## 4.2.5 TCP Slow Start

TCP의 성능은 TCP의 나이에 따라서도 좌우된다.

처음에는 천천히 시작했다가 점점 속도를 올린다.

만약 하나의 패킷이 성공적으로 받아졌다면 2개의 패킷을 추가로 더 보낼 수 있게 된다. 점점 보낼 수 있는 패킷의 수를 늘려간다. 이를 'opening the congestion window'라고 표현한다.

따라서 새로운 커넥션은 기존에 있던 커넥션보다 느리다. 따라서 HTTP는 기존에 존재하던 connection을 재사용하는 편의성 기능을 제공한다.

후에 'persistent connections (지속 커넥션)'에 대해서 더 자세하게 이야기한다.

## 4.2.6 Nagle의 알고리즘과 TCP_NODELAY

TCP 세그먼트 하나 당 40 byte의 플래그와 헤더 데이터가 추가되기 때문에, 적은 양의 데이터를 담은 많은 양의 패킷을 보내면 성능이 저하된다.

네이글 알고리즘은 패킷을 보내기 전에 많은 양의 데이터를 번들링해서 네트워크 효율을 올린다.

RFC896, "Congestion Control in IP/TCP Internetworks" 라는 곳에서 발견할 수 있다.

네이글 알고리즘은 세그먼트가 full size (수백 바이트에서 1500 바이트)가 아니면 보내는 것을 지양한다.

오직 acknowledge 되었을 때만 non-full-size packet을 보내는 것을 허용한다.

만약 다른 패킷이 여전히 보내지고 잇다면, partial data는 버퍼시킨다. 이 버퍼된 데이터는 오직 pending packet들이 awk되고 버퍼가 충분히 많은 데이터를 쌓았을 경우에만 보내진다.

> 추가적인 공부가 필요하다.

네이글 알고리즘은 성능 문제를 야기시킨다.

1. 작은 HTTP 메세지들이 패킷을 다 못 채울 수도 있어서 전송이 지연될 수도 있다.
2. disabled acknowledgement와의 연동이 좋지 않다.

다양한 이유 때문에 HTTP application들은 Nagle 알고리즘을 disable시킨다.

TCP_NODELAY 파라미터를 설정하면 된다. 이 경우 스스로 한번에 많은 데이터를 보내도록 노력해야 한다.

## 4.2.7 TIME_WAIT Accumulation과 Port Exhausion

TIME_WAIT은 벤치마킹을 할 때 심각한 성능 문제를 야기한다. 벤치마킹을 할 일이 있을 경우 이를 조심해야 한다.

TCP endpoint가 TCP 연결을 닫으면 메모리에 IP 주소와 포트 넘버를 기입한 작은 컨트롤 블록을 유지한다.
이 정보는 2MSL 동안 유지된다.

2MSL: twice the estimated maximum segment lifetime

보통 2분 정도이다.

그 시간 동안 같은 주소와 포트를 통한 TCP 연결을 만들지 않으려고 이러는 것이다.

떠도는 duplicate packet이 같은 주소와 포트를 통해 만들어진 새로운 커넥션에 실수로 잘못 주입되는 것을 막기 위함이다.

이 알고리즘을 통해 2분 안에 새로운 주소와 포트를 통해 새로운 연결이 만들어지는 것을 막을 수 있다.

요즘은 라우터가 빨라서 duplicate packet이 2분 후에 도착하는 일이 극히 드물다. 어떤 운영체제는 2MSL을 2분이 아니라 더 작은 값으로 바꿔두기도 하지만 주의하자!

근데 2MSL은 벤치마킹을 할 때 문제를 야기할 수 있다.

오직 한 대 혹은 몇 대의 테스트 컴퓨터만 벤치마크에 사용되므로, 서버에 연결될 때 계속 IP와 포트가 중복되어 2분 내에 만들 수 있는 커넥션의 갯수가 제한된다.

심지어, 서버는 보통 HTTP 용 포트 80만 사용한다.

2분 동안 사용할 수 있는 포트의 개수가 60000개 이하일 것이므로, 아무리 많아봤자 1초에 500개 정도밖에 만들 수 없다.

따라서 벤치마킹에서는 1초에 500개 이상의 transaction을 할 수 없는 것이다!!!

> 정말 좋은 정보를 배웠다.
