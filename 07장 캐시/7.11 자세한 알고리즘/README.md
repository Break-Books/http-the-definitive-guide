# 7.11 자세한 알고리즘

## 7.11.1 나이와 신선도 수명

캐시된 문서가 제공하기에 충분히 신선한지 알려주려면, 캐시는 캐시된 사본의 나이와 신선도 수명의 값만 계산하면 된다.   

+ 문서의 나이 = 서버가 문서를 보낸 후 그 문서가 나이를 먹은 시간의 총합
+ 문서의 신선도 수명 = 아직 문서가 신선하다고 볼 수 있는 수명으로, 이에 영향을 주는 클라이언트의 모든 요청을 고려해야 한다.

## 7.11.2 나이 계산

```
$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
```

+ Date나 Age 헤더를 분석해서 다음을 계산할 수 있다.
+ 캐시는 캐시된 사본이 얼마나 오랫동안 캐시되었는지는 쉽게 알아낼 수 있지만, 캐시에서 온 응답의 나이를 알아내는 것은 어렵다.       


_1. 겉보기 나이는 Date 헤더에 기반한다._
```
$문서가_우리의_캐시에_도착했을_때의_나이 = $겉보기_나이 = $응답을_받은_시각 - $Date_헤더값;
```
+ 모든 컴퓨터가 똑같이 정확한 시간을 갖고 있다면 (현재시간 - 문서를 보낸 시간) 으로 계산할 수 있다.
+ 클라이언트와 서버의 시계는 항상 잘 동기화되어 있지 않기 때문에 겉보기 나이는 종종 부정확할 가능성이 있으며 음수가 될 때도 있다.
+ 이 문제를 클럭 스큐라고 한다.

_2. 점층적 나이 계산_
```
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이;
```
+ 동기화된 시계가 없다는 문제를 해결하기 위해 문서가 프락시나 캐시를 통과할 때마다 Age 헤더에 상대적인 나이를 누적해서 더하도록 한다.
+ 이 방법은 서버 간의 시간 비교나 종단 간의 시간 비교를 필요로 하지 않는다.

_3. 네트워크 지연에 대한 보상_    

```
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
```
+ 트랜잭션은 느려질 수 있다. 따라서 느린 서버에서 문서 나이에 대한 추정이 잘못되었을 가능성이 있다.
+ 캐시와 서버의 왕복 지연 시간을 계산하는 것은 상대적으로 쉽다. (문서 요청 시각과 도착 시각을 알고 있기 때문)

## 7.11.3 완전한 나이 계산 알고리즘

```
$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_얼마나_오래_우리의_캐시에_있었는지;
```
+ 이 응답이 캐시에 한번 저장되면, 나이를 더 먹게 된다.
+ 문서에 대한 요청이 캐시에 도착했을 때, 현재 나이를 계산하기 위해 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알아야 한다.

## 7.11.4 신선도 수명 계산
+ 캐시된 문서가 클라이언트에게 제공해주기에 충분히 신선한지 계속해서 알아낸다.
+ 신선도 수명은 서버와 클라이언트의 제약조건에 의존한다.

## 7.11.5 완전한 서버 신선도 알고리즘
서버 신선도 한게를 계산하는 펄 알고리즘이 있다. (예 7-2 참고)
서버 신선도 한계를 가져와서 클라이언트의 제약에 맞게 수정할 수 있다. (예 7-3 참고)